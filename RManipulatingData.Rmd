### R Manipulating Data



## Recap So Far    

Dimension | Homogeneous   | Heterogeneous
--------- | ------------- | -------------
1d        | Atomic Vector | List
2d        | Matrix        | Data Frame

<br> 

Basic access via  

- Atomic vectors - `x[ ]`  
- Matrices - `x[ , ]`  
- Data Frames - `x[ , ]` or `x$name`  
- Lists - `x[ ]`, `x[[ ]]`, or `x$name`  


## Recap So Far  

- Reading Data

Type of file       | Package   | Function   
------------------ | --------- | -----------------
Delimited          | `readr`   | `read_csv()`, `read_tsv()`,`read_table()`, `read_delim(...,delim = ,...)`
Excel (.xls,.xlsx) | `readxl`  | `read_excel`
SPSS (.sav)        | `haven`   | `read_spss`
SAS (.sas7bdat)    | `haven`   | `read_sas`

<br>

- Resources for JSON, XML, databases, and APIs



## What is this course about?

Basic use of R for reading, manipulating, and plotting data!

- read and write basic R programs   
- import well formatted data into R
- **do basic data manipulation in R**   
- produce common numerical and graphical summaries in R  
- describe a use case of an analysis done in R  



## Where do we start?  

- Data manipulation idea  

- Documenting with Markdown  



## Where do we start?  

- Data manipulation idea  
  
- Documenting with Markdown  

- Logical statements 

- `dplyr`



## Where do we start?  

- Data manipulation idea  

- Documenting with Markdown

- Logical statements 

- `dplyr`

- Creating new variables  

     + Conditional execution (if then)  
     + For loops  
     + Vectorized functions   
 
- Reshaping Data


## Data manipulation idea  

We may want to subset our full data set or create new data   

- Grab only certain types of observations (**filter rows**)

```{r, echo = FALSE, fig.align='center', out.width = "400px"}
knitr::include_graphics("../img/filterVisual.png")
```


## Data manipulation idea  

We may want to subset our full data set or create new data   

- Look at only certain variables (**select columns**)  
    
```{r, echo = FALSE, fig.align='center', out.width = "300px"}
knitr::include_graphics("../img/selectVisual.png")
```


## Data manipulation idea  

We may want to subset our full data set or create new data   

- Create new variables

```{r, echo = FALSE, fig.align='center', out.width = "450px"}
knitr::include_graphics("../img/createVarVisual.png")
```



## Data manipulation idea  

We may want to subset our full data set or create new data   

- Grab only certain types of observations (**filter rows**)
    
- Look at only certain variables (**select columns**)  
    
- Create new variables
    
- Vital to make your work reproducible!  

> - Traditional documentation through comments (`#` in R) in script


## Documenting with Markdown  

- Communication and reproducibility vital!  

- May have heard of [JUPYTER](http://jupyter.org/) notebooks  



## Documenting with Markdown  

- Communication and reproducibility vital!  

- May have heard of [JUPYTER](http://jupyter.org/) notebooks  

- R Markdown - built in notebook for R studio  

- [Intro video](https://vimeo.com/178485416)




## Documenting with Markdown  


- R Markdown = Digital "Notebook":  Program that weaves word processing and code.  

- Designed to be used in three ways (R for Data Science)  




## Documenting with Markdown  


- R Markdown = Digital "Notebook":  Program that weaves word processing and code.  

- Designed to be used in three ways (R for Data Science)  
<ul>
  <li>Communicating to decision makers (focus on conclusions not code)</li>
  <li>Collaborating with other data scientists (including future you!)  </li>
  <li> As environment to do data science (documents what you did and what you were thinking)</li>
</ul>



## Documenting with Markdown  
**Verbage**

- May have heard of HTML (HyperText Mark-up Language)  
    + Write plain text that the browser interprets and renders  
    
    
## Documenting with Markdown  
**Verbage**

- May have heard of HTML (HyperText Mark-up Language)  
    + Write plain text that the browser interprets and renders  
    
- Markdown is a specific markup language  
    + Easier syntax  
    + Not as powerful  
    
- Any plain text file can be used (.Rmd extension associates it with R Studio)


## Documenting with Markdown  

R Markdown file contains three important types of content:

1. (Optional) YAML header surrounded by `---`s  

2. Chunks of R code   

3. Text mixed with simple text formatting instructions 


## Documenting with Markdown  
**Creating an R Markdown Document**

- R Studio makes it easy!  

```{r startMD.png, out.width = "700px",echo=FALSE, fig.align='center'}
knitr::include_graphics("../img/startMD.png")
```


## Documenting with Markdown  
**Creating an R Markdown Document**

- Commonly used document types can be created 

<div style="float: center;">
```{r startMDDoc.png, out.width = "500px",echo=FALSE, fig.align='center'}
knitr::include_graphics("../img/startMDDoc.png")
```
</div>



## Documenting with Markdown  
**Creating an R Markdown Document**

- Slide presentations 

```{r startMDPres.png, out.width = "500px",echo=FALSE, fig.align='center'}
knitr::include_graphics("../img/startMDPres.png")
```



## Documenting with Markdown  
**Creating an R Markdown Document**

- Truly Interactive Documents/Pages (require R backend)

```{r startMDShiny.png, out.width = "500px",echo=FALSE, fig.align='center'}
knitr::include_graphics("../img/startMDShiny.png")
```


## Documenting with Markdown  
**YAML Header**  

 - Define settings for document  

```
---
title: "Untitled"
author: "First Last"
date: "xxxx"
output: html_document
---
```  

- CTRL/CMD + Shift + k **knits** via this info 

     
## Documenting with Markdown  
**Code Chunks**  

 - Below YAML header: 'r chunk'  

```{r chunk_png, out.width = "500px",echo=FALSE, fig.align='center'}
knitr::include_graphics("../img/chunk.png")
```  

> - Start code chunk by typing ```{r} out or with CTRL/CMD + Alt + I

> - Code will be executed when document is created    

> - Can specify options on individual code chunks  



## Documenting with Markdown  
**Markdown Syntax**
     
- Below code chunk is plain text with markdown sytnax  

```
## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax
for authoring HTML, PDF, and MS Word documents. For more details on
using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that
includes both content as well as the output of any embedded R code
chunks within the document. 
```

- When file created, "##" becomes a header, "<...>" a link, and ```**Knit**``` bold font


## Documenting with Markdown  

### R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax
for authoring HTML, PDF, and MS Word documents. For more details on
using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that
includes both content as well as the output of any embedded R code
chunks within the document. 




## Where do we go from here?  

Briefly investigate:  

- Markdown syntax  

- Code chunks and their options  

- Changing type of output  



## Documenting with Markdown  

**Markdown syntax**  

- ```[Cheat Sheet link](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)``` becomes [Cheat Sheet link](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)  




## Documenting with Markdown  

**Markdown syntax**  

- ```[Cheat Sheet link](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)``` becomes [Cheat Sheet link](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)  

- ```# Header 1``` becomes a large font header  

- ```## Header 2``` becomes a slightly smaller font header  

- Goes to 6 headers  

    + Use of headers can automatically create a Table of Contents!



## Documenting with Markdown  

**Markdown syntax**  

- ```[Cheat Sheet link](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)``` becomes [Cheat Sheet link](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)  

- ```# Header 1``` becomes a large font header  

- ```## Header 2``` becomes a slightly smaller font header  

- Goes to 6 headers  

    + Use of headers can automatically create a Table of Contents!

- ```**bold**``` **and** ```__bold__```

- \`code\` becomes `code`  


## Documenting with Markdown  

**Markdown syntax**  

- Can do lists: be sure to end each line with two spaces!  

    + Indent sub lists four spaces  

<div style = "float: left; width: 50%">
```
* unordered list  
* item 2  
    + sub-item 1  
    + sub-item 2  

1. ordered list  
2. item 2  
    + sub-item 1  
    + sub-item 2  
```  
</div>
<div style = "float: right; width: 50%">
* unordered list  
* item 2  
    + sub-item 1  
    + sub-item 2  

1. ordered list  
2. item 2  
    + sub-item 1  
    + sub-item 2  
</div>


## Documenting with Markdown  

**Markdown syntax**  

- Can include nice tables (renders differently in slides than html doc)  

```
Table Header  | Second Header | Col 3
------------- | ------------- | -----------
Table Cell    | Cell (1, 2)   | Cell (1, 3)
Cell (2, 1)   | Cell (2, 2)   | Cell (2, 3) 
```
Table Header  | Second Header | Col 3
------------- | ------------- | -----------
Table Cell    | Cell (1, 2)   | Cell (1, 3)
Cell (2, 1)   | Cell (2, 2)   | Cell (2, 3) 




## Documenting with Markdown  

**Code chunks and their options**  


- Any R code can go into the chunk  

- Chunks evaluate sequentially (can use output from prior chunk)

> - Code can be added in line:  Ex: The Iris dataset has `r length(iris$Sepal.Length)` observations  

> - Added by beginning with back-tick `r` and ending with a back-tick: Iris has \`r `length(iris$Sepal.Length)`\`  



## Documenting with Markdown  

**Code chunks and their options**  

- Many options depending on chunk purpose!    

- Can hide/show code with `echo = FALSE/TRUE`  

- Can choose if code is evaluated with `eval = TRUE/FALSE`   

- `message = TRUE/FALSE` and `warning = TRUE/FALSE` can turn on/off displaying messages/warnings   



## Documenting with Markdown  

**Code chunks and their options**  

- Many options depending on chunk purpose!    

- Can hide/show code with `echo = FALSE/TRUE`  

- Can choose if code is evaluated with `eval = TRUE/FALSE`   

- `message = TRUE/FALSE` and `warning = TRUE/FALSE` can turn on/off displaying messages/warnings   

- Can set global options for all chunks  

```
opts_chunk$set(echo = FALSE, eval = TRUE, warning = FALSE)
```

- Allows for easy change of audience!  




## Documenting with Markdown  

**Changing type of output**  

R Markdown really flexible!  

```{r, echo = FALSE, fig.align='center'}
knitr::include_graphics("../img/compile.png")
```



## Documenting with Markdown  

**Changing type of output**  

Change output type in the YAML header:  

- Use CTRL/CMD + Shift + k or the Knit menu:

```{r knit, echo=FALSE, fig.align='center', out.width='150px'}
knitr::include_graphics("../img/knit.png")
```

> - Use code explicity:  
    `rmarkdown::render("file.Rmd", output_format = "word_document")`




## Documenting with Markdown  

**Changing type of output**  

For HTML & PDF can include Table of Contents with options    

```
output:
  html_document:
    toc: true
    toc_float: true
```


## Documenting with Markdown  

**Changing type of output**  

For HTML & PDF can include Table of Contents with options    

```
output:
  html_document:
    toc: true
    toc_float: true
```

For HTML another option is to make the code chunks hidden by default, but visible with a click:

```
output:
  html_document:
    code_folding: hide
```

## Documenting with Markdown  

**Changing type of output**  

HTML documents inherently interactive  

- Widgets can be included with appropriate **R package** 

```{r leafletP, echo = TRUE, eval = FALSE}
library(leaflet)
leaflet() %>%
  setView(174.764, -36.877, zoom = 16) %>% 
  addTiles() %>%
  addMarkers(174.764, -36.877, popup = "Maungawhau") 
```



## Documenting with Markdown  

**Changing type of output**  

```{r leafletE, echo = FALSE, eval = TRUE, fig.align='center'}
library(leaflet)
leaflet() %>%
  setView(174.764, -36.877, zoom = 16) %>% 
  addTiles() %>%
  addMarkers(174.764, -36.877, popup = "Maungawhau") 
```


## Documenting with Markdown  

**Changing type of output**  


- PDF  
    + Install MikTex and update its packages  

```
output: pdf_document   
```
  

## Documenting with Markdown  

**Changing type of output**  

- PDF  
    + Install MikTex and update its packages  

```
output: pdf_document   
```
  

- Word  

```
output: word_document
```

- Slides (## for new slide)



## Recap/Next Up! 

- Data manipulation idea  


- Documenting with Markdown

- Logical statements 

- `dplyr`

- Creating new variables  

     + Conditional execution (if then)  
     + For loops  
     + Vectorized functions   
 
- Reshaping Data 


## Where are we at?  

- Data manipulation idea  

- Documenting with Markdown

- Logical statements 

- `dplyr`

- Creating new variables  

     + Conditional execution (if then)  
     + For loops  
     + Vectorized functions   
 
- Reshaping Data


## Data manipulation idea  

We may want to subset our full data set or create new data   

- Grab only certain types of observations (**filter rows**)

```{r, echo = FALSE, fig.align='center', out.width = "400px"}
knitr::include_graphics("../img/filterVisual.png")
```



## Logical statements 

Goal: Subset rows or columns  

- **logical statement** - comparison that resolves as `TRUE` or `FALSE`  

<div style="float: left; width: 45%;">
```{r}
"hi" == " hi" #== is comparison
"hi" == "hi"
4 >= 1
```
</div>
<div style="float: right; width: 45%;">
```{r}
4 != 1
sqrt(3)^2  == 3
dplyr::near(sqrt(3)^2, 3)
```
</div>


## Logical statements 

Goal: Subset rows or columns  

- **logical statement** - comparison that resolves as `TRUE` or `FALSE`  

<div style="float: left; width: 45%;">
```{r}
#use of is. functions
is.numeric("Word")
is.numeric(10)
```
</div>
<div style="float: right; width: 45%;">
```{r}
is.character("10")
is.na(c(1:2, NA, 3))
is.matrix(c("hello", "world"))
```
</div>


## Logical statements 

Goal: Subset rows or columns  

- **logical statement** - useful for indexing an R object

```{r}
iris <- tbl_df(iris)
iris
```


## Logical statements 

Goal: Subset rows or columns  

- **logical statement** - useful for indexing an R object

- Concept:
    + Feed index a vector of `TRUE`/`FALSE` or `0`/`1` values  
    + R returns elements where `TRUE` or `1` occurred


```{r,eval=FALSE}
iris[iris$Species == "setosa", ]
```


## Logical statements 

- **logical statement** - useful for indexing an R object

- Concept:
    + Feed index a vector of `TRUE`/`FALSE` or `0`/`1` values  
    + R returns elements where `TRUE` or `1` occurred

```{r}
iris$Species == "setosa" #vector indicating setosa values
```


## Logical statements 

Goal: Subset rows or columns  

- **logical statement** - useful for indexing an R object

```{r}
iris[iris$Species == "setosa", ]
```


## Logical statements 

Goal: Subset rows or columns  

- **logical statement** - useful for indexing an R object

- Similarly, can use `subset` function  

```{r}
subset(iris, Species == "setosa")
```


## `dplyr`

Goal: Subset rows or columns  

- **logical statement** - useful for indexing an R object

- Similarly, can use `filter` from `dplyr` (installed with `tidyverse`)

```{r}
filter(iris, Species == "setosa")
```



## Logical statements 

Compound logicals via **Logical Operators**

- `&` 'and'
- `|` 'or'

Operator | A,B true       | A true, B false   | A,B false
---------|----------------|-------------------|--------------
`&`      | `A & B = TRUE` | `A & B = FALSE`   | `A & B = FALSE`
`|`      | `A | B = TRUE` | `A | B = TRUE`    | `A | B = FALSE`


## Logical statements 

Compound logicals via **Logical Operators**

- `&` 'and'
- `|` 'or'

Operator | A,B true       | A true, B false   | A,B false
---------|----------------|-------------------|--------------
`&`      | `A & B = TRUE` | `A & B = FALSE`   | `A & B = FALSE`
`|`      | `A | B = TRUE` | `A | B = TRUE`    | `A | B = FALSE`

- `&&` and `||` are alternatives  
  + Looks at only first comparison if given a vector of comparisons
  

## Logical statements 

Compound logicals via **Logical Operators**

```{r}
set.seed(3)
x <- runif(n = 10, min = 0, max = 1); x
(x < 0.25) | (x > 0.75)
(x < 0.25) || (x > 0.75)
```


## Logical statements 

Goal: Subset rows or columns  

- Only pull out large petal setosa flowers

```{r}
(iris$Petal.Length > 1.5) & (iris$Petal.Width > 0.3) & (iris$Species == "setosa")
```


## Logical statements 

Goal: Subset rows or columns  

- Only pull out large petal setosa flowers

```{r, eval = TRUE}
iris[(iris$Petal.Length > 1.5) & (iris$Petal.Width > 0.3) & 
         (iris$Species == "setosa"), ]
```



## Logical statements 

Goal: Subset rows or columns  

- Only pull out large petal setosa flowers

- Easier with `subset` or `filter`!

```{r}
filter(iris, (Petal.Length > 1.5) & (Petal.Width > 0.3) & 
         (Species == "setosa"))
```




## `dplyr`

**Overview of dplyr and tidyr packages**

- `dplry` package made for most standard data manipulation tasks    

- `tidyr` package reshapes data  

- Both part of `tidyverse`  

- Make sure `library(tidyverse)` has been run!  
 
 
## `dplyr` 

- Basic commands 
    + `tbl_df()` - convert data frame to one with better printing  
    + `filter()` - subset **rows**  
    + `arrange()` - reorder **rows**  
    + `select()` - subset **columns**  
    + `rename()` - rename **columns**  
    + `mutate()` - add newly created **column**  
    + `transmute()` - create new variable  
    + `group_by()` - group **rows** by a variable   
    + `summarise()` - apply basic function to data  



## Tidyverse Syntax

- Reason to prefer `dplyr` and packages from the `tidyverse` 

> - Fast!

> - Good defaults

> - All packages have similar syntax!  All work on `tibbles` (data frames)

> - Syntax:
`function(tibble, actions, ...)`


## `dplyr`

`tbl_df()` - convert data frame to one with better printing and no simplification

- Just 'wrap' data frame

```{r,eval=TRUE}
#install.packages("Lahman")
library(Lahman)
head(Batting, n = 4) #look at just first 4 observations
```



## `dplyr`

```{r}
Batting <- tbl_df(Batting)
Batting
```

- If data read in with `haven`, `readxl`, or `readr` probably in this format!


## `dplyr`

`filter()` - subset **rows**

- Use `filter()` to obtain only PIT data
```{r}
filter(Batting, teamID == "PIT")
```


## `dplyr`

`filter()` - subset **rows**

- Multiple filters
```{r}
filter(Batting, teamID == "PIT" & yearID == 2000)
```


## `dplyr`

`arrange()` - reorder **rows**

```{r}
#reorder by teamID
arrange(Batting, teamID)
```


## `dplyr`

`arrange()` - reorder **rows**

```{r}
#get secondary arrangement as well
arrange(Batting, teamID, G)
```


## `dplyr`

`arrange()` - reorder **rows**

```{r}
#descending instead
arrange(Batting, teamID, desc(G))
```



## Data manipulation idea  

We may want to subset our full data set or create new data   

- Look at only certain variables (**select columns**)  
    
```{r, echo = FALSE, fig.align='center', out.width = "300px"}
knitr::include_graphics("../img/selectVisual.png")
```



## `dplyr`

`select()` - subset **columns**

- Often only want select variables (saw `$` and `[ , ]`)
- `select()` function has same syntax as other `dplyr` functions!

```{r}
#Choose a single column by name
select(Batting, X2B)
```


## `dplyr`

`select()` - subset **columns**

- Often only want select variables (saw `$` and `[ , ]`)
- `select()` function has same syntax as other `dplyr` functions!

```{r}
#Choose a single column by name
select(Batting, playerID, X2B)
```


## Aside: Piping or Chaining

- Applying multiple functions: nesting hard to parse!
- Piping or Chaining with `%>%` operator helps

```{r}
arrange(select(filter(Batting, teamID == "PIT"), playerID, G, X2B), desc(X2B))
```


## Aside: Piping or Chaining

- Applying multiple functions: nesting hard to parse!
- Piping or Chaining with `%>%` operator helps

```{r}
Batting %>% filter(teamID == "PIT") %>% select(playerID, G, X2B) %>% arrange(desc(X2B)) 
```


## Aside: Piping or Chaining

- Generically, pipe does the following

`x %>% f(y)` turns into `f(x,y)`  

`x %>% f(y) %>% g(z)` turns into `g(f(x, y), z)`  

- Can be used with functions outside the tidyverse if this structure works!    


## `dplyr`

`select()` - subset **columns**

- Many ways to select variables 

```{r}
#all columns between
Batting %>% select(X2B:HR)
```


## `dplyr`

`select()` - subset **columns**

- Many ways to select variables 

```{r}
#all columns containing
Batting %>% select(contains("X"))
```


## `dplyr`

`select()` - subset **columns**

- Many ways to select variables 

```{r}
#all columns starting with
Batting %>% select(starts_with("X"))
```


## `dplyr`

`select()` - subset **columns**

- Many ways to select variables 

```{r}
#multiple selections
Batting %>% select(starts_with("X"), ends_with("ID"), G)
```


## `dplyr`

`select()` - subset **columns**

- Sometimes want to rename variables

```{r}
#rename our previous
Batting %>% 
  select(starts_with("X"), ends_with("ID"), G) %>% rename("Doubles" = X2B, "Triples" = X3B)
```


## `dplyr`

`select()` - subset **columns**

- May want to reorder variables

```{r}
#reorder
Batting %>% select(playerID, HR, everything())
```



## `dplyr`

[Cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

- Basic commands 
    + `tbl_df()` - convert data frame to one with better printing
    + `filter()` - subset **rows**
    + `arrange()` - reorder **rows**
    + `select()` - subset **columns**

- Many `joins` to combine tibbles too! (Similar to SQL)


## Recap/Next Up!

- Data manipulation idea  

- Documenting with Markdown

- Logical statements 

- `dplyr`

- Creating new variables  

     + Conditional execution (if then)  
     + For loops  
     + Vectorized functions   
     
- Reshaping Data


## Recap/Next Up!

- Data manipulation idea  

- Documenting with Markdown

- Logical statements 

- `dplyr`

- Creating new variables  

     + Conditional execution (if then)  
     + For loops  
     + Vectorized functions   
     
- Reshaping data

 

## Data manipulation idea  

We may want to subset our full data set or create new data   

- Create new variables

```{r, echo = FALSE, fig.align='center', out.width = "450px"}
knitr::include_graphics("../img/createVarVisual.png")
```

 
## Creating New Variables  

Given a data frame and an appropriate length vector (new variable) can use `cbind` (column bind)  

```{r}
temp <- cbind(iris, extra = rep("a", 150))
str(temp)
```


 
## Creating New Variables  

Or simply add as a named (list) element!  

```{r}
iris$extra <- rep("a", 150)
str(iris)
```



## Creating New Variables  

Better method: use `dplyr`!

- `mutate()` - add newly created **column(s)** to current data frame 

- `transmute()` - create new data frame with created variable(s)  



## Creating New Variables  

Better method: use `dplyr`!

- `mutate()` - add newly created **column(s)** to current data frame 

- `transmute()` - create new data frame with created variable(s)  

- Syntax:  

`mutate(data, newVarName = functionOfData, newVarName2 = functionOfData, ...)`  



## Creating New Variables  

- Consider a data set on movie ratings  

```{r,eval=TRUE}
library(fivethirtyeight)
fandango
```


## Creating New Variables  

- `mutate()` - add newly created **column(s)** to current data frame 

```{r}
##Create an average rottentomatoes score variable
fandango %>% mutate(avgRotten = (rottentomatoes + rottentomatoes_user)/2)
```


## Creating New Variables  

- `mutate()` - add newly created **column(s)** to current data frame 

```{r}
#can't see it!
fandango %>% mutate(avgRotten = (rottentomatoes + rottentomatoes_user)/2) %>% 
  select(film, year, avgRotten, everything())
```


## Creating New Variables  

- `mutate()` - add newly created **column(s)** to current data frame 

- Add more than one variable

```{r}
fandango %>% 
  mutate(avgRotten = (rottentomatoes + rottentomatoes_user)/2, 
         avgMeta = (metacritic_norm + metacritic_user_nom)/2) %>%
  select(film, year, avgRotten, avgMeta, everything())
```



## Creating New Variables  

- `transmute()` - create new data frame with created variable(s)  

```{r}
#transmute will keep the new variable(s) only
fandango %>% transmute(avgRotten = (rottentomatoes + rottentomatoes_user)/2)
```


## Creating New Variables  

- `transmute()` - create new data frame with created variable(s)  

```{r}
#transmute will keep the new variable(s) only
fandango %>% transmute(avgRotten = (rottentomatoes + rottentomatoes_user)/2, 
                       avgMeta = (metacritic_norm + metacritic_user_nom)/2) 
```



## Creating New Variables  

`mutate` and `transmute` can also use 'window' functions  

 - functions that take a vector of values and return another vector of values (see [Cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf))
 
```{r}
fandango %>% select(rottentomatoes) %>% mutate(cumulativeSum = cumsum(rottentomatoes))
```



## Creating New Variables  

`mutate` and `transmute` can also use some statistical functions
 
```{r}
fandango %>% select(rottentomatoes) %>% 
  mutate(avg = mean(rottentomatoes), sd = sd(rottentomatoes))
```

## Creating New Variables  

`mutate` and `transmute` can also use some statistical functions

- `group_by` to create summaries for groups (more on this later)
 
```{r}
fandango %>% select(year, rottentomatoes) %>% 
  group_by(year) %>% mutate(avg = mean(rottentomatoes), sd = sd(rottentomatoes))
```



## Creating New Variables  
**Conditional Execution with If then, If then else**

- Often want to execute statements conditionally 

- `if` `then` `else` syntax

<div style="float: left; width: 45%;">
```{r,eval=FALSE}
if (condition) {
  then execute code
} 

#if then else
if (condition) {
  execute this code  
} else {
  execute this code
}
```
</div>


<div style="float: right; width: 45%;">
```{r,eval=FALSE}
#Or more if statements
if (condition) {
  execute this code  
} else if (condition2) {
  execute this code
} else if (condition3) {
  execute this code
} else {
  #if no conditions met
  execute this code
}
```
</div>




## Creating New Variables  
**Conditional Execution with If then, If then else**

- Consider built-in data set `airquality`  

    + daily air quality measurements in New York  
    
    + from May (Day 1) to September (Day 153) in 1973  
    

## Creating New Variables  
**Conditional Execution with If then, If then else**

- Consider built-in data set `airquality`  

```{r}
airquality <- tbl_df(airquality)
airquality
```


## Creating New Variables  
**Conditional Execution with If then, If then else**

Want to code a wind category variable    

 + high wind days (15mph $\leq$ wind)  
 + windy days     (10mph $\leq$ wind < 15mph)  
 + lightwind days (6mph $\leq$ wind < 10mph)  
 + calm days      (wind $\leq$ 6mph)


## Creating New Variables  
**Conditional Execution with If then, If then else**

Want to code a wind category variable    

Issue: `if(condition)` can only take in a single comparison  

```{r, error = TRUE, message = TRUE, warning = TRUE}
if(airquality$Wind >= 15) { 
  "High Wind"
  }
```



## Creating New Variables  
**Conditional Execution with If then, If then else**

Want to code a wind category variable    

 + high wind days (15mph $\leq$ wind)  
 + windy days     (10mph $\leq$ wind < 15mph)  
 + lightwind days (6mph $\leq$ wind < 10mph)  
 + calm days      (wind $\leq$ 6mph)  

Initial plan    

  + loop through each observation    
  
  + use if then else to determine wind status    
  
    

## Looping in R  

- There are a number of ways to do looping in R  

    + `for()`  
    + `while()`
    + `repeat()`
    
- Idea: 
    + Run code repeatedly changing something each time
    

## Looping in R  

- Syntax  

```{r,eval=FALSE}
for(index in values){
  code to be run
}
```

> - index defines 'counter' or variable that varies

> - 'values' define which values index takes on


## Looping in R  

- index defines 'counter' or variable that varies

- 'values' define which values index takes on

```{r}
for (i in 1:10){
  print(i)
}
```


## Looping in R  

- index defines 'counter' or variable that varies

- 'values' define which values index takes on

```{r}
for (index in c("cat","hat","worm")){
  print(index)
}
```


## Creating New Variables  
**Conditional Execution with If then, If then else**

Want to code a wind category variable    

```{r}
status<-vector() #initialize vector to save results

for (i in 1:nrow(airquality)){
  if(airquality$Wind[i] >= 15){
    status[i] <- "HighWind"
  } else if (airquality$Wind[i] >= 10){
    status[i] <- "Windy"
  } else if (airquality$Wind[i] >= 6){
    status[i] <- "LightWind"
  } else if (airquality$Wind[i] >= 0){
    status[i] <- "Calm"
  } else {
    status[i] <- "Error"
  }
}
```


## Creating New Variables  
**Conditional Execution with If then, If then else**

```{r}
airquality$status <- status
airquality$status
```



## Looping in R  

**Other things to know**  

- `break` kicks you out of the loop  

```{r}
for (i in 1:5){
	if (i == 3){ 
	  break 
	  }
  print(i)
}
```



## Looping in R  

**Other things to know**  

- `next` jumps to the next iteration of the loop  

```{r}
for (i in 1:5){
	if (i == 3){
	  next
	} 
  print(i)
}
```


## Looping in R  

**Other things to know**  

- `while` loop similar  

```{r, eval = FALSE}
while(condition) {
	expression to evaluate
  modify condition?
}
```



## Looping in R  

**Other things to know**  

For loops inefficient in R  

> + R interpreted language  

> + Must figure out how to evaluate code at each iteration of loop  

> + Slows it down  



## Looping in R  

**Other things to know**  

For loops inefficient in R  

 + R interpreted language  

 + Must figure out how to evaluate code at each iteration of loop  
 
 + Slows it down  

Vectorized functions much faster!  

> + Vectorized function: works on entire vector at once  

> + Avoids costly computation time  
   


## Creating New Variables  
**Vectorized ifelse**

- `ifelse()` is vectorized version of `if then else`

- Syntax

```{r,eval=FALSE}
ifelse(vector_condition, if_true_do_this, if_false_do_this)
```


## Creating New Variables  
**Vectorized ifelse**

```{r}
ifelse(airquality$Wind >= 15, "HighWind",
          ifelse(airquality$Wind >= 10, "Windy",
                 ifelse(airquality$Wind >= 6, "LightWind", "Calm")))
```



## Creating New Variables  
**Vectorized ifelse**

- Can use with `transmute()` or `mutate()` 

```{r}
mutate(airquality, status = ifelse(airquality$Wind >= 15, "HighWind",
                                ifelse(airquality$Wind >= 10, "Windy",
                                       ifelse(airquality$Wind >= 6, "LightWind", "Calm")))
)
```



## Creating New Variables  

- Compare speed of for loop and vectorized version

- `microbenchmark` package runs code repeatedly, returns summary stats

```{r}
#install if needed
library(microbenchmark)
```


## Creating New Variables  

- Compare speed of for loop and vectorized version

```{r}
loopTime <- microbenchmark(
  for (i in 1:nrow(airquality)){
    if(airquality$Wind[i] >= 15){
      status[i] <- "HighWind"
    } else if (airquality$Wind[i] >= 10){
      status[i] <- "Windy"
    } else if (airquality$Wind[i] >= 6){
      status[i] <- "LightWind"
    } else if (airquality$Wind[i] >= 0){
      status[i] <- "Calm"
    } else{
      status[i] <- "Error"
    }
  }
, unit = "us")
```


## Creating New Variables  

- Compare speed of for loop and vectorized version

```{r}
vectorTime <- microbenchmark(
  ifelse(airquality$Wind >= 15, "HighWind",
            ifelse(airquality$Wind >= 10, "Windy",
                   ifelse(airquality$Wind >= 6, "LightWind", "Calm")))
, unit = "us")
```

## Creating New Variables  

```{r}
loopTime
vectorTime
```


## Creating New Variables Recap!

- Add new column with `$`  

- `mutate()` - add newly created **column(s)** to current data frame 

- `transmute()` - create new data frame with created variable(s)  

    + Can use with window functions

    + Use `ifelse()` to do conditional creation
    
    + Note: `cut()` can be used to categorize a numeric variable too!



## Reshaping Data  
**`tidyr` package**

Easily allows for two very important actions

> - `gather()` - takes multiple columns, and gathers them into key-value pairs  
    <ul>  
        <li> Make wide data longer</li>  
        <li> Most important as analysis methods often prefer this form</li>  
    </ul>  
         
> - `spread()` - takes two columns (key & value) and spreads in to multiple columns  
    <ul> <li> Make "long" data wider </li></ul>


## Reshaping Data  
**`tidyr` package**

Easily allows for two very important actions

- `gather()` - takes multiple columns, and gathers them into key-value pairs  

    + Make wide data longer  
    + Most important as analysis methods often prefer this form  

- `spread()` - takes two columns (key & value) and spreads in to multiple columns  
    <ul> <li> Make "long" data wider </li></ul>
    
Also gives an easy method to separate a column (or combine two columns) using `separate()` and `unite()`


## Reshaping Data  
**`tidyr` package**

- Data in 'Wide' form


```{r, eval = FALSE}
tempsData <- read_table2(file = "https://www4.stat.ncsu.edu/~online/datasets/cityTemps.txt") 
tempsData
```
```{r, echo = FALSE}
tempsData <- read_table2(file = "../datasets/cityTemps.txt")
tempsData
```



## Manipulating Data
**tidyr package**

- Switch to 'Long' form with `gather()`  
    + key = new name for values in columns  
    + value = new name for data values  
    + columns describe which columns to take  
```{r}
tempsData %>% gather(key = day, value = temp, 2:8)
```


## Reshaping Data  
**tidyr package**

- Switch to 'Long' form with `gather()`  
- Can provide columns to `gather()` in many ways!
```{r}
newTempsData <- tempsData %>% gather(key = day, value = temp, sun:sat)
newTempsData
```

## Reshaping Data  
**tidyr package**

- Switch to 'Wide' form with `spread()`  
    + opposite from gather  
    + key = new column names  
    + value = value to spread out  

```{r}
newTempsData %>% spread(key = day, value = temp)
```

## Reshaping Data  
**tidyr package**

- Separate a column (or combine two columns) using `separate()` and `unite()`

- Consider data set on air pollution in Chicago  


```{r, eval = FALSE}
chicagoData <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/Chicago.csv")
chicagoData
```
```{r, echo = FALSE}
chicagoData <- read_csv("../datasets/Chicago.csv")
chicagoData
```


## Manipulating Data
**tidyr package**

- `lubridate` package great for date data!  Can parse with `separate`:

```{r}
chicagoData %>% separate(date, c("Day", "Month", "Year"), sep = "/", 
												 convert = TRUE, remove = FALSE)
```



## Manipulating Data
**tidyr package**

- `lubridate` package great for date data!  Combine with `unite`:

```{r}
chicagoData %>% separate(date, c("Day", "Month", "Year"), sep = "/", 
												 convert = TRUE, remove = FALSE) %>%
  unite(DayMonth, Day, Month, sep = "-")
```


## Recap/Next Up!

- Data manipulation idea  

- Documenting with Markdown

- Logical statements 

- `dplyr`

- Creating new variables  

     + Conditional execution (if then)  
     + For loops  
     + Vectorized functions   
     
- Reshaping data
